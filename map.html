<!DOCTYPE html>
<meta charset="utf-8">
<style>

.background {
  fill: none;
  pointer-events: all;
}

#states {
  fill: #aaa;
}

#states .active {
  fill: lightsteelblue;
}

#state-borders {
  fill: none;
  stroke: #fff;
  stroke-width: 1.5px;
  stroke-linejoin: round;
  stroke-linecap: round;
  pointer-events: none;
}

.node {
  cursor: pointer;
}

.node circle {
  fill: #fff;
  stroke: steelblue;
  stroke-width: 1.5px;
}

.node text {
  font: 1.2em Optima;
}

.link {
  fill: none;
  stroke: #ccc;
  stroke-width: 1.5px;
}

</style>
<body>
    <div id = "viz"></div>
<script src="//d3js.org/d3.v3.min.js"></script>
<script src="//d3js.org/topojson.v1.min.js"></script>
<script src="js/jquery.js"></script>
<script src="stateList.js"></script>
<script>

var width  = parseInt(d3.select("#viz").style("width").slice(0, -2)),
    height = $(window).height() - 15,
    active = d3.select(null),
    treeHeight = height * 0.9,
    margin = {top: (height - treeHeight)/2, right: 240, bottom: 5, left: width/4, padding: 20};;

    var projection = d3.geo.albersUsa()
        .scale(1000)
        .translate([width / 2, height / 2]);

    var zoom = d3.behavior.zoom()
        .translate([0, 0])
        .scale(1)
        .scaleExtent([1, 8])
        .on("zoom", zoomed);

    var path = d3.geo.path()
        .projection(projection);

    var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height)
        .on("click", stopped, true);

    svg.append("rect")
        .attr("class", "background")
        .attr("width", width)
        .attr("height", height)
        .on("click", reset);

    var g = svg.append("g");

    svg
        // .call(zoom) // delete this line to disable free zooming
        .call(zoom.event);

d3.json("us.json", function(error, us) {
  if (error) throw error;

  g.append("g")
      .attr("id", "states")
    .selectAll("path")
      .data(topojson.feature(us, us.objects.states).features)
    .enter().append("path")
      .attr("d", path)
      .on("click", clicked)
      .on("mouseover",hovered)
      .on("mouseout", un_hovered);

  g.append("path")
      .datum(topojson.mesh(us, us.objects.states, function(a, b) { return a !== b; }))
      .attr("id", "state-borders")
      .attr("d", path);
});

function hovered(d){
    d3.select(this)
        .attr("fill", "steelblue")
}

function un_hovered(d){
    d3.select(this)
        .attr("fill", "#aaa")
}

function clicked(d) {
  if (active.node() === this) return reset();
  active.classed("active", false);
  active = d3.select(this).classed("active", true);

  dateSelector()
  // drawTree(stateKeys[d.id])

  var bounds = path.bounds(d),
      dx = bounds[1][0] - bounds[0][0],
      dy = bounds[1][1] - bounds[0][1],
      x = (bounds[0][0] + bounds[1][0]) / 2,
      y = (bounds[0][1] + bounds[1][1]) / 2,
      scale = Math.max(1, Math.min(8, 0.9 / Math.max(dx / width, dy / height))),
      translate = [width / 2 - scale * x, height / 2 - scale * y];

  svg.transition()
      .duration(750)
      .call(zoom.translate(translate).scale(scale).event);
}

function reset() {
    d3.select(".treeViz").remove()
  active.classed("active", false);
  active = d3.select(null);

  svg.transition()
      .duration(750)
      .call(zoom.translate([0, 0]).scale(1).event);
}

function zoomed() {
  g.style("stroke-width", 1.5 / d3.event.scale + "px");
  g.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
}

// If the drag behavior prevents the default click,
// also stop propagation so we don’t click-to-zoom.
function stopped() {
  if (d3.event.defaultPrevented) d3.event.stopPropagation();
}


//------------------------------------------------------------------------------
// Time selector code

function dateSelector(){
    var radius = Math.min(width, height) / 4,
        thickness = radius * 0.4;

    var color_scale = d3.scale.linear()
        .domain([0, 12])
        .range(['lightsteelblue', 'green']);

    var arc = d3.svg.arc()
        .outerRadius(radius + thickness*0.73)
        .innerRadius(radius );

    var time = d3.svg.arc()
        .outerRadius(radius + 2*thickness)
        .innerRadius(radius + thickness)
        .cornerRadius(5);

    var pie = d3.layout.pie()
        .startAngle(-90 * Math.PI/180)
        .endAngle(-90 * Math.PI/180 + 2*Math.PI)
        .padAngle(0.005)
        .sort(null)
        .value(function(d) { return 1; });

    //draw background rectangle to display viz on.
    svg.append("rect")
        .attr("id", "background_rectangle")
        .attr("width", width)
        .attr("height", height)
        .attr("fill", "lightgrey")
        .attr("fill-opacity", 0.5)
        .on("click", cancel)

    var dateChooser = svg.append("g")
        .attr("id", "dateChooser")
        .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

    function drawDates(dates){
        var months = ["Jan", "Feb", "Mar", "April", "May", "June", "July", "Aug", "Sep", "Oct", "Nov", "Dec"]

        var g = dateChooser.selectAll(".months")
              .data(pie(months))
            .enter().append("g")
              .attr("class", "months")

        //Create the donut slices and also the invisible arcs for the text
        g.append("path")
        	.attr("class", "donutArcSlices")
        	.attr("d", arc)
        	.style("fill", "white")
            .style("fill-opacity", 0)
            .attr("id", function(d,i) { return "arc_"+i; }) //Give each slice a unique ID
        	.each(function(d,i) {
        		//A regular expression that captures all in between the start of a string (denoted by ^)
        		//and the first capital letter L
        		var firstArcSection = /(^.+?)L/;

        		//The [1] gives back the expression between the () (thus not the L as well)
        		//which is exactly the arc statement
        		var newArc = firstArcSection.exec( d3.select(this).attr("d") )[1];
        		//Replace all the comma's so that IE can handle it -_-
        		//The g after the / is a modifier that "find all matches rather than stopping after the first match"
        		newArc = newArc.replace(/,/g , " ");

                //If the end angle lies beyond a quarter of a circle (90 degrees or pi/2)
                //flip the end and start position
                if (d.endAngle >= 100 * Math.PI/180) {
                    var startLoc 	= /M(.*?)A/,		//Everything between the capital M and first capital A
                        middleLoc 	= /A(.*?)0 0 1/,	//Everything between the capital A and 0 0 1
                        endLoc 		= /0 0 1 (.*?)$/;	//Everything between the 0 0 1 and the end of the string (denoted by $)
                    //Flip the direction of the arc by switching the start and end point (and sweep flag)
                    var newStart  = endLoc.exec( newArc )[1];
                    var newEnd    = startLoc.exec( newArc )[1];
                    var middleSec = middleLoc.exec( newArc )[1];

                    //Build up the new arc notation, set the sweep-flag to 0
                    newArc = "M" + newStart + "A" + middleSec + "0 0 0 " + newEnd;
                }//if

        		//Create a new invisible arc that the text can flow along
        		svg.append("path")
        			.attr("class", "hiddenDonutArcs")
        			.attr("id", "donutArc"+i)
        			.attr("d", newArc)
        			.style("fill", "none");
        	});

        //Append the label names on the outside
        g.append("text")
            .attr("class", "donutText")
            .attr("dy", function(d,i) { return (d.endAngle > 100 * Math.PI/180 ? 10 : 0); })
            .append("textPath")
            .attr("startOffset","50%")
            .style("text-anchor","middle")
            .attr("xlink:href",function(d,i){return "#donutArc"+i;})
            .text(function(d){return d.data;});

        //draw the part that shows early and late.
        var g = dateChooser.selectAll(".times")
              .data(pie(dates))
            .enter().append("g")
              .attr("class", "times")
              .on("mouseover", moused)
              .on("mouseout", unmoused)
              .on("click", clicked);

        g.append("path")
          .attr("d", time)
          .style("fill",  function(d,i){return i < 12 ? color_scale(i) : color_scale(12 - (i - 12))})

        g.append("text")
          .attr("transform", function(d) { return "translate(" + time.centroid(d) + ")"; })
          .attr("dy", ".35em")
          .attr("text-anchor", "middle")
          .text(function(d,i) {return i%2 == 0 ? "early" : "late";});
    }

    function moused(d){
        console.log(d)
        d3.select(this).select("path")
            .attr("stroke-width", "4")
            .attr("stroke", "black")
    }

    function unmoused(d){
        console.log(d)
        d3.select(this).select("path")
            .attr("stroke-width", "0")
    }

    function clicked(d){
        alert("You have selected the time period of " + d.data)
    }

    function cancel(d){
        dateChooser.remove()
        d3.select("#background_rectangle").remove()
        reset()
    }

    d3.json("seasonData_d3.json", function(data){
        var times = data.children[1].children.map(function(d){return d.name})
        drawDates(times)
    })
}



//------------------------------------------------------------------------------
// Code for the tree viz.

function drawTree(state){
    var i = 0,
        duration = 750,
        root,
        treeHeight = height * 0.9,
        margin = {top: (height - treeHeight)/2, right: 240, bottom: 5, left: width/4, padding: 20};

    var tree = d3.layout.tree()
        .size([treeHeight, width]);

    var diagonal = d3.svg.diagonal()
        .projection(function(d) { return [d.y, d.x]; });

    var svg = d3.select("svg").append("g")
        .attr("class", "treeViz")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    //draw background rectangle to display viz on.
    svg.append("rect")
        .attr("id", "background_rectangle")
        .attr("width", width)
        .attr("height", height)
        .attr("fill", "lightgrey")
        .attr("fill-opacity", 0.5)

    d3.json("seasonData_d3.json", function(error, grow_data) {
      if (error) throw error;

      //filter the data to the selected state:
      grow_data.children.forEach(function(d){       //scroll through the children vector
          if(d.name == state){ root = d }
      })

      root.x0 = height / 2;
      root.y0 = 0;

      function collapse(d) {
        if (d.children) {
          d._children = d.children;
          d._children.forEach(collapse);
          d.children = null;
        }
      }

      root.children.forEach(collapse);
      update(root);
    });

    function update(source) {

      // Compute the new tree layout.
      var nodes = tree.nodes(root).reverse(),
          links = tree.links(nodes);

      // Normalize for fixed-depth.
      //modify this to change how wide the tree gets. make divisible by width - length of longest veggie name.
      nodes.forEach(function(d) { d.y = d.depth * 180; });

      // Update the nodes…
      var node = svg.selectAll("g.node")
          .data(nodes, function(d) { return d.id || (d.id = ++i); });

      // Enter any new nodes at the parent's previous position.
      var nodeEnter = node.enter().append("g")
          .attr("class", "node")
          .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
          .on("click", click);

      nodeEnter.append("circle")
          .attr("r", 1e-6)
          .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

      nodeEnter.append("text")
          .attr("x", function(d) { return d.children || d._children ? 8 : 8; })
          .attr("dy", ".35em")
          .attr("class", function(d){ return d.depth == 0 ? "rootNode": "childNode"})
          .attr("text-anchor","start")
          .text(function(d) { return d.name; })
          .style("fill-opacity", 1e-6);

      // Transition nodes to their new position.
      var nodeUpdate = node.transition()
          .duration(duration)
          .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

      nodeUpdate.select("circle")
          .attr("r", 4.5)
          .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

      nodeUpdate.select("text")
          .style("fill-opacity", 1);

      // Transition exiting nodes to the parent's new position.
      var nodeExit = node.exit().transition()
          .duration(duration)
          .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
          .remove();

      nodeExit.select("circle")
          .attr("r", 1e-6);

      nodeExit.select("text")
          .style("fill-opacity", 1e-6);

      // Update the links…
      var link = svg.selectAll("path.link")
          .data(links, function(d) { return d.target.id; });

      // Enter any new links at the parent's previous position.
      link.enter().insert("path", "g")
          .attr("class", "link")
          .attr("d", function(d) {
            var o = {x: source.x0, y: source.y0};
            return diagonal({source: o, target: o});
          });

      // Transition links to their new position.
      link.transition()
          .duration(duration)
          .attr("d", diagonal);

      // Transition exiting nodes to the parent's new position.
      link.exit().transition()
          .duration(duration)
          .attr("d", function(d) {
            var o = {x: source.x, y: source.y};
            return diagonal({source: o, target: o});
          })
          .remove();

      // Stash the old positions for transition.
      nodes.forEach(function(d) {
        d.x0 = d.x;
        d.y0 = d.y;
      });
    }

    // Toggle children on click.
    function click(d) {
      if (d.children) {
        d._children = d.children;
        d.children = null;
      } else {
        d.children = d._children;
        d._children = null;
      }
      update(d);
    }
}

</script>
